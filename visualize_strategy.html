<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker Strategy Visualizer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #fff;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        label {
            color: #aaa;
            font-size: 14px;
        }

        select, input[type="text"] {
            background: #2a2a4a;
            color: #fff;
            border: 1px solid #4a4a6a;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: #4a4a6a;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
        }

        .btn:hover {
            background: #5a5a8a;
        }

        .btn.active {
            background: #007bff;
        }

        .view-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .view-tab {
            background: #3a3a5a;
            color: #aaa;
            border: none;
            padding: 10px 25px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .view-tab:hover {
            background: #4a4a6a;
        }

        .view-tab.active {
            background: #007bff;
            color: #fff;
        }

        /* Preflop Chart Styles */
        .chart-container {
            display: none;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .chart-container.active {
            display: flex;
        }

        .chart-wrapper {
            background: #252540;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .chart-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            color: #fff;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            gap: 2px;
            width: fit-content;
        }

        .cell {
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            position: relative;
            overflow: hidden;
        }

        .cell:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            z-index: 10;
        }

        .cell .hand-label {
            text-shadow: 0 1px 3px rgba(0,0,0,0.9), 0 0 6px rgba(0,0,0,0.6);
            position: relative;
            z-index: 2;
            font-weight: 700;
        }

        .cell.no-data {
            background: #2a2a3a;
            color: #555;
        }

        /* Segmented background for mixed strategies */
        .cell-segments {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: row;
            z-index: 1;
        }

        .cell-segment {
            height: 100%;
            flex-shrink: 0;
        }

        /* Postflop Styles */
        .postflop-container {
            display: none;
        }

        .postflop-container.active {
            display: block;
        }

        .metadata-panel {
            background: #252540;
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 20px;
            display: none;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .metadata-panel.active {
            display: flex;
        }

        .metadata-item {
            text-align: center;
        }

        .metadata-value {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
        }

        .metadata-label {
            font-size: 12px;
            color: #888;
        }

        .strategy-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 15px;
            max-height: 70vh;
            overflow-y: auto;
            padding: 10px;
        }

        .strategy-card {
            background: #252540;
            border-radius: 10px;
            padding: 15px;
            transition: transform 0.2s;
        }

        .strategy-card:hover {
            transform: translateY(-2px);
        }

        .strategy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #3a3a5a;
        }

        .strategy-info {
            font-size: 12px;
            color: #888;
        }

        .strategy-info .position {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            margin-right: 8px;
        }

        .strategy-info .position.p0 {
            background: #2d4a2d;
            color: #8f8;
        }

        .strategy-info .position.p1 {
            background: #4a2d2d;
            color: #f88;
        }

        .strategy-info .street {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            background: #3a3a5a;
            margin-right: 8px;
        }

        .strategy-info .bucket {
            color: #aaa;
        }

        .history-line {
            font-family: monospace;
            font-size: 13px;
            color: #7af;
            margin-bottom: 12px;
            word-break: break-all;
        }

        .action-bars {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .action-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .action-name {
            width: 100px;
            font-size: 12px;
            color: #aaa;
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bar-container {
            flex: 1;
            height: 20px;
            background: #1a1a2e;
            border-radius: 4px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            padding-left: 8px;
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .bar-fill.fold { background: linear-gradient(90deg, #007bff, #0056b3); }
        .bar-fill.check { background: linear-gradient(90deg, #6c757d, #5a6268); }
        .bar-fill.call { background: linear-gradient(90deg, #28a745, #218838); }
        .bar-fill.bet { background: linear-gradient(90deg, #17a2b8, #138496); }
        .bar-fill.raise { background: linear-gradient(90deg, #dc3545, #c82333); }
        .bar-fill.allin { background: linear-gradient(90deg, #fd7e14, #e96b02); }

        .tooltip {
            position: fixed;
            background: #2a2a4a;
            border: 1px solid #4a4a6a;
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            display: none;
            min-width: 220px;
        }

        .tooltip.visible {
            display: block;
        }

        .tooltip-hand {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #fff;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
        }

        .tooltip-action {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tooltip-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .stats {
            text-align: center;
            margin-top: 20px;
            color: #888;
        }

        .stats span {
            margin: 0 15px;
        }

        .info-panel {
            background: #252540;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        .info-panel p {
            color: #aaa;
            line-height: 1.6;
        }

        .drop-zone {
            border: 2px dashed #4a4a6a;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: border-color 0.2s, background 0.2s;
        }

        .drop-zone.dragover {
            border-color: #7a7aaa;
            background: rgba(74, 74, 106, 0.2);
        }

        .drop-zone p {
            color: #888;
            margin-bottom: 15px;
        }

        .no-results {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 16px;
        }

        .format-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }

        .format-badge.preflop {
            background: #28a745;
            color: #fff;
        }

        .format-badge.postflop {
            background: #007bff;
            color: #fff;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #4a4a6a;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #5a5a8a;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üÉè Poker Strategy Visualizer <span class="format-badge" id="formatBadge"></span></h1>
        <p class="subtitle">Interactive strategy chart viewer</p>

        <div class="drop-zone" id="dropZone">
            <p>Drag & drop your solution JSON file here, or</p>
            <label class="btn">
                Choose File
                <input type="file" id="fileInput" accept=".json">
            </label>
        </div>

        <!-- View Tabs (for postflop format with preflop data) -->
        <div class="view-tabs" id="viewTabs" style="display:none">
            <button class="view-tab active" data-view="preflop-grid">Preflop Grid</button>
            <button class="view-tab" data-view="postflop-list">All Strategies</button>
        </div>

        <!-- Preflop Grid Controls -->
        <div class="controls preflop-grid-controls" id="preflopGridControls" style="display:none">
            <div class="control-group">
                <label>Position:</label>
                <select id="preflopPositionFilter">
                    <option value="0">SB (P0)</option>
                    <option value="1">BB (P1)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Scenario:</label>
                <select id="preflopScenarioFilter">
                    <option value="">RFI (Open)</option>
                </select>
            </div>
        </div>

        <!-- Postflop Controls -->
        <div class="controls postflop-controls" id="postflopControls" style="display:none">
            <div class="control-group">
                <label>Player:</label>
                <select id="playerFilter">
                    <option value="">All</option>
                    <option value="0">P0 (SB)</option>
                    <option value="1">P1 (BB)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Street:</label>
                <select id="streetFilter">
                    <option value="">All</option>
                    <option value="0">Preflop</option>
                    <option value="1">Flop</option>
                    <option value="2">Turn</option>
                    <option value="3">River</option>
                </select>
            </div>
            <div class="control-group">
                <label>Search:</label>
                <input type="text" id="historySearch" placeholder="Filter by history...">
            </div>
        </div>

        <!-- Metadata Panel -->
        <div class="metadata-panel" id="metadataPanel">
            <div class="metadata-item">
                <div class="metadata-value" id="metaConfig">-</div>
                <div class="metadata-label">Config</div>
            </div>
            <div class="metadata-item">
                <div class="metadata-value" id="metaStack">-</div>
                <div class="metadata-label">Stack (BB)</div>
            </div>
            <div class="metadata-item">
                <div class="metadata-value" id="metaIterations">-</div>
                <div class="metadata-label">Iterations</div>
            </div>
            <div class="metadata-item">
                <div class="metadata-value" id="metaInfoSets">-</div>
                <div class="metadata-label">Info Sets</div>
            </div>
        </div>

        <!-- Preflop Grid View -->
        <div class="chart-container" id="preflopGridContainer">
        </div>

        <!-- Postflop List View -->
        <div class="postflop-container" id="postflopContainer">
            <div class="strategy-list" id="strategyList">
            </div>
        </div>

        <div class="legend" id="legend"></div>
        <div class="stats" id="stats"></div>

        <div class="tooltip" id="tooltip"></div>

        <div class="info-panel">
            <h3>How to Use</h3>
            <p>
                <strong>solution.json (Solver Output):</strong><br>
                ‚Ä¢ <strong>Preflop Grid</strong> - Shows 13√ó13 hand chart with action frequencies<br>
                ‚Ä¢ <strong>All Strategies</strong> - Browse all info sets (preflop + postflop)<br><br>
                <strong>Colors:</strong>
                <span style="color:#007bff">Fold</span>,
                <span style="color:#28a745">Call</span>,
                <span style="color:#dc3545">Raise</span>,
                <span style="color:#17a2b8">Bet</span>,
                <span style="color:#6c757d">Check</span>,
                <span style="color:#fd7e14">All-In</span>
            </p>
        </div>
    </div>

    <script>
        // Rank characters (index 0 = 2, index 12 = A)
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
        // For grid display (row/col 0 = A, row/col 12 = 2)
        const GRID_RANKS = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'];

        // Convert bucket (0-168) to hand name
        // Matches Rust abstraction.rs: HandClass::from_index
        function bucketToHand(bucket) {
            if (bucket < 13) {
                // Pairs: bucket 0 = 22, bucket 12 = AA
                return RANKS[bucket] + RANKS[bucket];
            } else if (bucket < 91) {
                // Suited hands (13-90)
                const idx = bucket - 13;
                const [r1, r2] = decodeTriangular(idx);
                return RANKS[r1] + RANKS[r2] + 's';
            } else if (bucket < 169) {
                // Offsuit hands (91-168)
                const idx = bucket - 91;
                const [r1, r2] = decodeTriangular(idx);
                return RANKS[r1] + RANKS[r2] + 'o';
            }
            return `B${bucket}`;
        }

        // Decode triangular index to (r1, r2) where r1 > r2
        function decodeTriangular(idx) {
            let r1 = 1;
            let remaining = idx;
            while (remaining >= r1) {
                remaining -= r1;
                r1++;
            }
            return [r1, remaining];
        }

        // Convert hand name to grid position (row, col)
        // Grid: row 0 = A, col 0 = A; diagonal = pairs; above = suited; below = offsuit
        function handToGridPos(hand) {
            const rank1 = hand[0];
            const rank2 = hand[1];
            const suited = hand.length === 3 && hand[2] === 's';
            const offsuit = hand.length === 3 && hand[2] === 'o';
            const isPair = rank1 === rank2;

            const r1Idx = GRID_RANKS.indexOf(rank1);
            const r2Idx = GRID_RANKS.indexOf(rank2);

            if (isPair) {
                return [r1Idx, r1Idx];
            } else if (suited) {
                // Suited: higher rank as row, lower rank as col (above diagonal)
                return [Math.min(r1Idx, r2Idx), Math.max(r1Idx, r2Idx)];
            } else {
                // Offsuit: lower rank as row, higher rank as col (below diagonal)
                return [Math.max(r1Idx, r2Idx), Math.min(r1Idx, r2Idx)];
            }
        }

        // Get hand label for grid position
        function getGridHandLabel(row, col) {
            if (row === col) {
                return GRID_RANKS[row] + GRID_RANKS[col];
            } else if (col > row) {
                return GRID_RANKS[row] + GRID_RANKS[col] + 's';
            } else {
                return GRID_RANKS[col] + GRID_RANKS[row] + 'o';
            }
        }

        // Action colors: Fold = Blue, Call = Green, Raise = Red
        const ACTION_COLORS = {
            'FOLD': '#007bff',      // Blue
            'CALL': '#28a745',      // Green
            'RAISE': '#dc3545',     // Red
            'ALLIN': '#fd7e14',     // Orange
            'ALL-IN': '#fd7e14',    // Orange
            'CHECK': '#6c757d',     // Gray
            'BET': '#17a2b8'        // Cyan
        };

        // Priority order for sorting actions in segments (top to bottom)
        const ACTION_PRIORITY = {
            'RAISE': 1,
            'ALLIN': 2,
            'ALL-IN': 2,
            'BET': 3,
            'CALL': 4,
            'CHECK': 5,
            'FOLD': 6
        };

        function getActionColor(actionName) {
            const upper = actionName.toUpperCase();
            for (const [key, color] of Object.entries(ACTION_COLORS)) {
                if (upper.includes(key)) return color;
            }
            return '#6c757d';
        }

        function getActionPriority(actionName) {
            const upper = actionName.toUpperCase();
            for (const [key, priority] of Object.entries(ACTION_PRIORITY)) {
                if (upper.includes(key)) return priority;
            }
            return 99;
        }

        // Create segmented cell content for mixed strategies
        function createCellSegments(actions) {
            if (!actions || actions.length === 0) return null;

            // Sort by priority (aggressive actions on top)
            const sorted = [...actions]
                .filter(a => a.freq > 0.001) // Filter out tiny frequencies
                .sort((a, b) => getActionPriority(a.name) - getActionPriority(b.name));

            if (sorted.length === 0) return null;

            // Create segments
            const segments = document.createElement('div');
            segments.className = 'cell-segments';

            sorted.forEach(action => {
                const segment = document.createElement('div');
                segment.className = 'cell-segment';
                segment.style.width = `${action.freq * 100}%`;
                segment.style.backgroundColor = getActionColor(action.name);
                segments.appendChild(segment);
            });

            return segments;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Global state
        let currentData = null;
        let currentView = 'preflop-grid';
        let tooltip = document.getElementById('tooltip');

        // Parse postflop solution (solution.json format)
        function parsePostflopSolution(data) {
            const metadata = data.metadata || {};
            const strategies = data.strategies || {};

            const parsed = Object.values(strategies).map(s => ({
                infoKey: s.info_key,
                position: s.position,
                street: s.street,
                bucket: s.bucket,
                history: s.history,
                actions: s.actions,
                strategy: s.strategy,
                hand: s.street === 0 ? bucketToHand(s.bucket) : null
            }));

            // Get unique scenarios (histories) for preflop
            const preflopScenarios = new Set();
            parsed.filter(s => s.street === 0).forEach(s => {
                preflopScenarios.add(s.history);
            });

            return {
                metadata,
                strategies: parsed,
                preflopScenarios: Array.from(preflopScenarios).sort()
            };
        }

        // Build preflop grid data
        function buildPreflopGridData(parsed, position, historyFilter) {
            const gridData = {};

            // Initialize all hands with no data
            for (let row = 0; row < 13; row++) {
                for (let col = 0; col < 13; col++) {
                    const hand = getGridHandLabel(row, col);
                    gridData[hand] = { actions: [], row, col };
                }
            }

            // Fill in data from strategies
            parsed.strategies
                .filter(s => s.street === 0 && s.position === position)
                .filter(s => historyFilter === '' ? s.history === '' : s.history === historyFilter)
                .forEach(s => {
                    const hand = s.hand;
                    if (hand && gridData[hand]) {
                        gridData[hand].actions = s.actions.map((name, i) => ({
                            name: name,
                            freq: s.strategy[i]
                        })).filter(a => a.freq > 0);
                    }
                });

            return gridData;
        }

        // Render preflop grid
        function renderPreflopGrid(parsed) {
            const position = parseInt(document.getElementById('preflopPositionFilter').value);
            const historyFilter = document.getElementById('preflopScenarioFilter').value;
            const gridData = buildPreflopGridData(parsed, position, historyFilter);

            const container = document.getElementById('preflopGridContainer');
            container.innerHTML = '';

            const wrapper = document.createElement('div');
            wrapper.className = 'chart-wrapper';

            const title = document.createElement('div');
            title.className = 'chart-title';
            const posName = position === 0 ? 'SB' : 'BB';
            const scenario = historyFilter === '' ? 'RFI (Open)' : historyFilter;
            title.textContent = `${posName} - ${scenario}`;
            wrapper.appendChild(title);

            const grid = document.createElement('div');
            grid.className = 'grid';

            // Collect all unique actions for legend
            const allActions = new Set();

            for (let row = 0; row < 13; row++) {
                for (let col = 0; col < 13; col++) {
                    const hand = getGridHandLabel(row, col);
                    const data = gridData[hand];

                    const cell = document.createElement('div');
                    cell.className = 'cell';

                    if (data.actions.length === 0) {
                        cell.classList.add('no-data');
                        cell.style.backgroundColor = '#2a2a3a';
                        cell.style.color = '#555';
                    } else {
                        // Create segmented background for mixed strategies
                        const segments = createCellSegments(data.actions);
                        if (segments) {
                            cell.appendChild(segments);
                        }

                        // Collect actions for legend
                        data.actions.forEach(a => allActions.add(a.name));

                        // White text with shadow for readability over any color
                        cell.style.color = '#fff';
                    }

                    const label = document.createElement('span');
                    label.className = 'hand-label';
                    label.textContent = hand;
                    cell.appendChild(label);

                    cell.addEventListener('mouseenter', (e) => showGridTooltip(e, hand, data));
                    cell.addEventListener('mousemove', moveTooltip);
                    cell.addEventListener('mouseleave', hideTooltip);

                    grid.appendChild(cell);
                }
            }

            wrapper.appendChild(grid);
            container.appendChild(wrapper);

            // Render legend
            renderGridLegend(Array.from(allActions));

            // Render stats
            const handsWithData = Object.values(gridData).filter(d => d.actions.length > 0).length;
            document.getElementById('stats').innerHTML = `<span>Hands with data: ${handsWithData} / 169</span>`;
        }

        function renderGridLegend(actionNames) {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';

            // Deduplicate by action type
            const types = {};
            actionNames.forEach(name => {
                const type = parseActionType(name);
                if (!types[type]) {
                    types[type] = name;
                }
            });

            for (const [type, name] of Object.entries(types)) {
                const item = document.createElement('div');
                item.className = 'legend-item';

                const color = document.createElement('div');
                color.className = 'legend-color';
                color.style.backgroundColor = getActionColor(name);

                const label = document.createElement('span');
                label.textContent = name.split(' ')[0]; // Just the action type

                item.appendChild(color);
                item.appendChild(label);
                legend.appendChild(item);
            }
        }

        function showGridTooltip(e, hand, data) {
            let html = `<div class="tooltip-hand">${hand}</div>`;

            if (data.actions.length === 0) {
                html += '<div style="color:#666">No data for this spot</div>';
            } else {
                // Sort by frequency
                const sorted = [...data.actions].sort((a, b) => b.freq - a.freq);
                sorted.forEach(action => {
                    html += `
                        <div class="tooltip-row">
                            <div class="tooltip-action">
                                <div class="tooltip-color" style="background:${getActionColor(action.name)}"></div>
                                <span>${action.name}</span>
                            </div>
                            <span>${(action.freq * 100).toFixed(1)}%</span>
                        </div>
                    `;
                });
            }

            tooltip.innerHTML = html;
            tooltip.classList.add('visible');
            moveTooltip(e);
        }

        // Render postflop list
        function renderPostflopList(parsed) {
            const playerFilter = document.getElementById('playerFilter').value;
            const streetFilter = document.getElementById('streetFilter').value;
            const historySearch = document.getElementById('historySearch').value.toLowerCase();

            let filtered = parsed.strategies.filter(s => {
                if (playerFilter !== '' && s.position !== parseInt(playerFilter)) return false;
                if (streetFilter !== '' && s.street !== parseInt(streetFilter)) return false;
                if (historySearch && !s.history.toLowerCase().includes(historySearch)) return false;
                return true;
            });

            // Sort
            filtered.sort((a, b) => {
                if (a.street !== b.street) return a.street - b.street;
                if (a.position !== b.position) return a.position - b.position;
                return a.bucket - b.bucket;
            });

            const list = document.getElementById('strategyList');
            list.innerHTML = '';

            if (filtered.length === 0) {
                list.innerHTML = '<div class="no-results">No strategies match the current filters</div>';
                return;
            }

            const displayLimit = 200;
            const displayed = filtered.slice(0, displayLimit);

            displayed.forEach(strategy => {
                const card = document.createElement('div');
                card.className = 'strategy-card';

                const streetNames = { 0: 'Preflop', 1: 'Flop', 2: 'Turn', 3: 'River' };
                const handLabel = strategy.hand ? ` (${strategy.hand})` : '';

                card.innerHTML = `
                    <div class="strategy-header">
                        <div class="strategy-info">
                            <span class="position p${strategy.position}">P${strategy.position}</span>
                            <span class="street">${streetNames[strategy.street] || 'S' + strategy.street}</span>
                            <span class="bucket">Bucket ${strategy.bucket}${handLabel}</span>
                        </div>
                    </div>
                    <div class="history-line">${formatHistory(strategy.history) || '<em style="color:#555">Root (first action)</em>'}</div>
                    <div class="action-bars">
                        ${strategy.actions.map((action, i) => {
                            const prob = strategy.strategy[i] * 100;
                            const actionType = parseActionType(action);
                            return `
                                <div class="action-bar">
                                    <span class="action-name" title="${action}">${action}</span>
                                    <div class="bar-container">
                                        <div class="bar-fill ${actionType}" style="width: ${prob}%">
                                            ${prob >= 5 ? prob.toFixed(1) + '%' : ''}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;

                list.appendChild(card);
            });

            if (filtered.length > displayLimit) {
                const notice = document.createElement('div');
                notice.className = 'no-results';
                notice.textContent = `Showing ${displayLimit} of ${filtered.length} results. Use filters to narrow down.`;
                list.appendChild(notice);
            }

            document.getElementById('legend').innerHTML = '';
            document.getElementById('stats').innerHTML = `<span>Showing: ${Math.min(displayLimit, filtered.length)} of ${filtered.length} info sets</span>`;
        }

        function formatHistory(history) {
            if (!history) return '';
            return history
                .replace(/\|/g, ' <span style="color:#555">|</span> ')
                .replace(/R(\d+)/g, '<span style="color:#007bff">R$1</span>')
                .replace(/B(\d+)/g, '<span style="color:#17a2b8">B$1</span>')
                .replace(/C(?![a-z])/g, '<span style="color:#28a745">C</span>')
                .replace(/X/g, '<span style="color:#6c757d">X</span>')
                .replace(/A(?![a-z])/g, '<span style="color:#fd7e14">A</span>');
        }

        function parseActionType(action) {
            const lower = action.toLowerCase();
            if (lower.includes('fold')) return 'fold';
            if (lower.includes('check')) return 'check';
            if (lower.includes('call')) return 'call';
            if (lower.includes('all-in') || lower.includes('allin')) return 'allin';
            if (lower.includes('raise')) return 'raise';
            if (lower.includes('bet')) return 'bet';
            return 'bet';
        }

        function moveTooltip(e) {
            const x = e.clientX + 15;
            const y = e.clientY + 15;
            const rect = tooltip.getBoundingClientRect();
            const maxX = window.innerWidth - rect.width - 10;
            const maxY = window.innerHeight - rect.height - 10;
            tooltip.style.left = Math.min(x, maxX) + 'px';
            tooltip.style.top = Math.min(y, maxY) + 'px';
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
        }

        // Switch view
        function switchView(view) {
            currentView = view;

            // Update tab styles
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === view);
            });

            // Show/hide containers and controls
            const isPreflopGrid = view === 'preflop-grid';
            document.getElementById('preflopGridContainer').classList.toggle('active', isPreflopGrid);
            document.getElementById('postflopContainer').classList.toggle('active', !isPreflopGrid);
            document.getElementById('preflopGridControls').style.display = isPreflopGrid ? 'flex' : 'none';
            document.getElementById('postflopControls').style.display = isPreflopGrid ? 'none' : 'flex';

            // Re-render
            if (currentData) {
                if (isPreflopGrid) {
                    renderPreflopGrid(currentData);
                } else {
                    renderPostflopList(currentData);
                }
            }
        }

        // Initialize UI for postflop format
        function initPostflopUI(parsed) {
            // Show view tabs
            document.getElementById('viewTabs').style.display = 'flex';

            // Show metadata
            document.getElementById('metadataPanel').classList.add('active');
            document.getElementById('metaConfig').textContent = parsed.metadata.config_name || '-';
            document.getElementById('metaStack').textContent = parsed.metadata.stack_bb || '-';
            document.getElementById('metaIterations').textContent = parsed.metadata.iterations?.toLocaleString() || '-';
            document.getElementById('metaInfoSets').textContent = parsed.metadata.num_info_sets?.toLocaleString() || '-';

            // Populate scenario filter
            const scenarioFilter = document.getElementById('preflopScenarioFilter');
            scenarioFilter.innerHTML = '<option value="">RFI (Open)</option>';
            parsed.preflopScenarios.filter(s => s !== '').forEach(scenario => {
                const opt = document.createElement('option');
                opt.value = scenario;
                opt.textContent = scenario || 'Open';
                scenarioFilter.appendChild(opt);
            });

            // Add filter event listeners
            document.getElementById('preflopPositionFilter').addEventListener('change', () => {
                if (currentView === 'preflop-grid') renderPreflopGrid(currentData);
            });
            document.getElementById('preflopScenarioFilter').addEventListener('change', () => {
                if (currentView === 'preflop-grid') renderPreflopGrid(currentData);
            });

            ['playerFilter', 'streetFilter', 'historySearch'].forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    if (currentView !== 'preflop-grid') renderPostflopList(currentData);
                });
            });

            // Add view tab listeners
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.addEventListener('click', () => switchView(tab.dataset.view));
            });

            // Start with preflop grid view
            switchView('preflop-grid');
        }

        // File handling
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    // Check format
                    if (data.strategies && data.metadata) {
                        // Postflop format (solution.json)
                        currentData = parsePostflopSolution(data);

                        const badge = document.getElementById('formatBadge');
                        badge.textContent = 'Solver Output';
                        badge.className = 'format-badge postflop';

                        initPostflopUI(currentData);
                    } else if (data.action_solutions) {
                        // Legacy preflop format
                        alert('This is the old preflop format. Please use the new solver output format.');
                    } else {
                        alert('Unknown file format.');
                    }
                } catch (err) {
                    alert('Error parsing JSON: ' + err.message);
                    console.error(err);
                }
            };
            reader.readAsText(file);
        }

        // Event listeners
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files[0]) handleFile(e.target.files[0]);
        });

        const dropZone = document.getElementById('dropZone');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
        });
    </script>
</body>
</html>
